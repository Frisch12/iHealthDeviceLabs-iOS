<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>AsyncSocket Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">ynote </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">youdao</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	

	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/acceptOnAddress:port:error:">- acceptOnAddress:port:error:</option>
		
		<option value="//api/name/acceptOnPort:error:">- acceptOnPort:error:</option>
		
		<option value="//api/name/attachSocketsToRunLoop:error:">- attachSocketsToRunLoop:error:</option>
		
		<option value="//api/name/close">- close</option>
		
		<option value="//api/name/configureSocketAndReturnError:">- configureSocketAndReturnError:</option>
		
		<option value="//api/name/configureStreamsAndReturnError:">- configureStreamsAndReturnError:</option>
		
		<option value="//api/name/connectToAddress:error:">- connectToAddress:error:</option>
		
		<option value="//api/name/connectToAddress:withTimeout:error:">- connectToAddress:withTimeout:error:</option>
		
		<option value="//api/name/connectToHost:onPort:error:">- connectToHost:onPort:error:</option>
		
		<option value="//api/name/connectToHost:onPort:withTimeout:error:">- connectToHost:onPort:withTimeout:error:</option>
		
		<option value="//api/name/connectedHost">- connectedHost</option>
		
		<option value="//api/name/createAcceptSocketForAddress:error:">- createAcceptSocketForAddress:error:</option>
		
		<option value="//api/name/createStreamsFromNative:error:">- createStreamsFromNative:error:</option>
		
		<option value="//api/name/createStreamsToHost:onPort:error:">- createStreamsToHost:onPort:error:</option>
		
		<option value="//api/name/delegate">- delegate</option>
		
		<option value="//api/name/disconnect">- disconnect</option>
		
		<option value="//api/name/disconnectAfterReading">- disconnectAfterReading</option>
		
		<option value="//api/name/disconnectAfterReadingAndWriting">- disconnectAfterReadingAndWriting</option>
		
		<option value="//api/name/disconnectAfterWriting">- disconnectAfterWriting</option>
		
		<option value="//api/name/doAcceptWithSocket:">- doAcceptWithSocket:</option>
		
		<option value="//api/name/doBytesAvailable">- doBytesAvailable</option>
		
		<option value="//api/name/doSocketOpen:withCFSocketError:">- doSocketOpen:withCFSocketError:</option>
		
		<option value="//api/name/doStreamOpen">- doStreamOpen</option>
		
		<option value="//api/name/enablePreBuffering">- enablePreBuffering</option>
		
		<option value="//api/name/getAbortError">- getAbortError</option>
		
		<option value="//api/name/getConnectTimeoutError">- getConnectTimeoutError</option>
		
		<option value="//api/name/getErrnoError">- getErrnoError</option>
		
		<option value="//api/name/getReadMaxedOutError">- getReadMaxedOutError</option>
		
		<option value="//api/name/getReadTimeoutError">- getReadTimeoutError</option>
		
		<option value="//api/name/getSocketError">- getSocketError</option>
		
		<option value="//api/name/getWriteTimeoutError">- getWriteTimeoutError</option>
		
		<option value="//api/name/hasBytesAvailable">- hasBytesAvailable</option>
		
		<option value="//api/name/maybeDequeueRead">- maybeDequeueRead</option>
		
		<option value="//api/name/maybeScheduleDisconnect">- maybeScheduleDisconnect</option>
		
		<option value="//api/name/moveToRunLoop:">- moveToRunLoop:</option>
		
		<option value="//api/name/progressOfReadReturningTag:bytesDone:total:">- progressOfReadReturningTag:bytesDone:total:</option>
		
		<option value="//api/name/readDataToData:withTimeout:maxLength:tag:">- readDataToData:withTimeout:maxLength:tag:</option>
		
		<option value="//api/name/readDataToData:withTimeout:tag:">- readDataToData:withTimeout:tag:</option>
		
		<option value="//api/name/readDataToLength:withTimeout:tag:">- readDataToLength:withTimeout:tag:</option>
		
		<option value="//api/name/readDataWithTimeout:tag:">- readDataWithTimeout:tag:</option>
		
		<option value="//api/name/readIntoBuffer:maxLength:">- readIntoBuffer:maxLength:</option>
		
		<option value="//api/name/scheduleDequeueRead">- scheduleDequeueRead</option>
		
		<option value="//api/name/setRunLoopModes:">- setRunLoopModes:</option>
		
		<option value="//api/name/startTLS:">- startTLS:</option>
		
		<option value="//api/name/unreadData">- unreadData</option>
		
		<option value="//api/name/writeData:withTimeout:tag:">- writeData:withTimeout:tag:</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">AsyncSocket Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>AsyncSocket.h<br />AsyncSocket.m</td>
</tr>
						</tbody></table></div>
					

                    

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/delegate" title="delegate"></a>
	<h3 class="method-title"><code><a href="#//api/name/delegate">&ndash;&nbsp;delegate</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Use &ldquo;canSafelySetDelegate&rdquo; to see if there is any pending business (reads and writes) with the current delegate
before changing it.  It is, of course, safe to change the delegate before connecting or accepting connections.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (id)delegate</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Use &ldquo;canSafelySetDelegate&rdquo; to see if there is any pending business (reads and writes) with the current delegate
before changing it.  It is, of course, safe to change the delegate before connecting or accepting connections.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/acceptOnPort:error:" title="acceptOnPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/acceptOnPort:error:">&ndash;&nbsp;acceptOnPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Tells the socket to begin listening and accepting connections on the given port.
When a connection comes in, the AsyncSocket instance will call the various <a href="#//api/name/delegate">delegate</a> methods (see above).
The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Tells the socket to begin listening and accepting connections on the given port.
When a connection comes in, the AsyncSocket instance will call the various <a href="#//api/name/delegate">delegate</a> methods (see above).
The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/acceptOnAddress:port:error:" title="acceptOnAddress:port:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/acceptOnAddress:port:error:">&ndash;&nbsp;acceptOnAddress:port:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the additional option
of specifying which interface to listen on. So, for example, if you were writing code for a server that
has multiple IP addresses, you could specify which address you wanted to listen on.  Or you could use it
to specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that
the socket only accept connections from the local machine.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnAddress:(NSString *)<em>hostaddr</em> port:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the additional option
of specifying which interface to listen on. So, for example, if you were writing code for a server that
has multiple IP addresses, you could specify which address you wanted to listen on.  Or you could use it
to specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that
the socket only accept connections from the local machine.</p>

<p>To accept connections on any interface pass nil, or simply use the <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects to the given host and port.
The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;)</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Connects to the given host and port.
The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;)</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToHost:onPort:withTimeout:error:" title="connectToHost:onPort:withTimeout:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToHost:onPort:withTimeout:error:">&ndash;&nbsp;connectToHost:onPort:withTimeout:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is the same as <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is the same as <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetservice&rsquo;s addresses method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetservice&rsquo;s addresses method.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:withTimeout:error:" title="connectToAddress:withTimeout:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:withTimeout:error:">&ndash;&nbsp;connectToAddress:withTimeout:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnect" title="disconnect"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnect">&ndash;&nbsp;disconnect</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects immediately. Any pending reads or writes are dropped.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnect</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects immediately. Any pending reads or writes are dropped.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterReading" title="disconnectAfterReading"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterReading">&ndash;&nbsp;disconnectAfterReading</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReading</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterWriting" title="disconnectAfterWriting"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterWriting">&ndash;&nbsp;disconnectAfterWriting</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterWriting</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterReadingAndWriting" title="disconnectAfterReadingAndWriting"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterReadingAndWriting">&ndash;&nbsp;disconnectAfterReadingAndWriting</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReadingAndWriting</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectedHost" title="connectedHost"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectedHost">&ndash;&nbsp;connectedHost</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSString *)connectedHost</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:tag:" title="readDataToLength:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToLength:withTimeout:tag:">&ndash;&nbsp;readDataToLength:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This will read a certain number of bytes into memory, and call the <a href="#//api/name/delegate">delegate</a> method when those bytes have been read.
If there is an error, partially read data is lost.
If the length is 0, this method does nothing and the <a href="#//api/name/delegate">delegate</a> is not called.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(CFIndex)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This will read a certain number of bytes into memory, and call the <a href="#//api/name/delegate">delegate</a> method when those bytes have been read.
If there is an error, partially read data is lost.
If the length is 0, this method does nothing and the <a href="#//api/name/delegate">delegate</a> is not called.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:tag:" title="readDataToData:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToData:withTimeout:tag:">&ndash;&nbsp;readDataToData:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes and the separator are returned by the <a href="#//api/name/delegate">delegate</a> method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes and the separator are returned by the <a href="#//api/name/delegate">delegate</a> method.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for
a character, the read will prematurely end.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:maxLength:tag:" title="readDataToData:withTimeout:maxLength:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToData:withTimeout:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:maxLength:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Same as readDataToData:withTimeout:tag, with the additional restriction that the amount of data read
may not surpass the given maxLength (specified in bytes).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> maxLength:(CFIndex)<em>length</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Same as readDataToData:withTimeout:tag, with the additional restriction that the amount of data read
may not surpass the given maxLength (specified in bytes).</p>

<p>If you pass a maxLength parameter that is less than the length of the data parameter,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If the max length is surpassed, it is treated the same as a timeout - the socket is closed.</p>

<p>Pass -1 as maxLength if no length restriction is desired, or simply use the readDataToData:withTimeout:tag method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataWithTimeout:tag:" title="readDataWithTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataWithTimeout:tag:">&ndash;&nbsp;readDataWithTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads the first available bytes that become available on the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads the first available bytes that become available on the socket.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/writeData:withTimeout:tag:" title="writeData:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/writeData:withTimeout:tag:">&ndash;&nbsp;writeData:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)writeData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>

<p>If you pass in nil or zero-length data, this method does nothing and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/progressOfReadReturningTag:bytesDone:total:" title="progressOfReadReturningTag:bytesDone:total:"></a>
	<h3 class="method-title"><code><a href="#//api/name/progressOfReadReturningTag:bytesDone:total:">&ndash;&nbsp;progressOfReadReturningTag:bytesDone:total:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns progress of current read or write, from 0.0 to 1.0, or NaN if no read/write (use isnan() to check).
&ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (float)progressOfReadReturningTag:(long *)<em>tag</em> bytesDone:(CFIndex *)<em>done</em> total:(CFIndex *)<em>total</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns progress of current read or write, from 0.0 to 1.0, or NaN if no read/write (use isnan() to check).
&ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/startTLS:" title="startTLS:"></a>
	<h3 class="method-title"><code><a href="#//api/name/startTLS:">&ndash;&nbsp;startTLS:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Secures the connection using SSL/TLS.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)startTLS:(NSDictionary *)<em>tlsSettings</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Secures the connection using SSL/TLS.</p>

<p>This method may be called at any time, and the TLS handshake will occur after all pending reads and writes
are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing
the upgrade to TLS at the same time, without having to wait for the write to finish.
Any reads or writes scheduled after this method is called will occur over the secured connection.</p>

<p>The possible keys and values for the TLS settings are well documented.
Some possible keys are:
- kCFStreamSSLLevel
- kCFStreamSSLAllowsExpiredCertificates
- kCFStreamSSLAllowsExpiredRoots
- kCFStreamSSLAllowsAnyRoot
- kCFStreamSSLValidatesCertificateChain
- kCFStreamSSLPeerName
- kCFStreamSSLCertificates
- kCFStreamSSLIsServer</p>

<p>Please refer to Apple&rsquo;s documentation for associated values, as well as other possible keys.</p>

<p>If you pass in nil or an empty dictionary, this method does nothing and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/enablePreBuffering" title="enablePreBuffering"></a>
	<h3 class="method-title"><code><a href="#//api/name/enablePreBuffering">&ndash;&nbsp;enablePreBuffering</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>For handling readDataToData requests, data is necessarily read from the socket in small increments.
The performance can be much improved by allowing AsyncSocket to read larger chunks at a time and
store any overflow in a small internal buffer.
This is termed pre-buffering, as some data may be read for you before you ask for it.
If you use readDataToData a lot, enabling pre-buffering will result in better performance, especially on the iPhone.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)enablePreBuffering</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>For handling readDataToData requests, data is necessarily read from the socket in small increments.
The performance can be much improved by allowing AsyncSocket to read larger chunks at a time and
store any overflow in a small internal buffer.
This is termed pre-buffering, as some data may be read for you before you ask for it.
If you use readDataToData a lot, enabling pre-buffering will result in better performance, especially on the iPhone.</p>

<p>The default pre-buffering state is controlled by the DEFAULT_PREBUFFERING definition.
It is highly recommended one leave this set to YES.</p>

<p>This method exists in case pre-buffering needs to be disabled by default for some reason.
In that case, this method exists to allow one to easily enable pre-buffering when ready.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/moveToRunLoop:" title="moveToRunLoop:"></a>
	<h3 class="method-title"><code><a href="#//api/name/moveToRunLoop:">&ndash;&nbsp;moveToRunLoop:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>When you create an AsyncSocket, it is added to the runloop of the current thread.
So for manually created sockets, it is easiest to simply create the socket on the thread you intend to use it.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)moveToRunLoop:(NSRunLoop *)<em>runLoop</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>When you create an AsyncSocket, it is added to the runloop of the current thread.
So for manually created sockets, it is easiest to simply create the socket on the thread you intend to use it.</p>

<p>If a new socket is accepted, the <a href="#//api/name/delegate">delegate</a> method onSocket:wantsRunLoopForNewSocket: is called to
allow you to place the socket on a separate thread. This works best in conjunction with a thread pool design.</p>

<p>If, however, you need to move the socket to a separate thread at a later time, this
method may be used to accomplish the task.</p>

<p>This method must be called from the thread/runloop the socket is currently running on.</p>

<p>Note: After calling this method, all further method calls to this object should be done from the given runloop.
Also, all <a href="#//api/name/delegate">delegate</a> calls will be sent on the given runloop.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setRunLoopModes:" title="setRunLoopModes:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setRunLoopModes:">&ndash;&nbsp;setRunLoopModes:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows you to configure which run loop modes the socket uses.
The default set of run loop modes is NSDefaultRunLoopMode.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)setRunLoopModes:(NSArray *)<em>runLoopModes</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Allows you to configure which run loop modes the socket uses.
The default set of run loop modes is NSDefaultRunLoopMode.</p>

<p>If you&rsquo;d like your socket to continue operation during other modes, you may want to add modes such as
NSModalPanelRunLoopMode or NSEventTrackingRunLoopMode. Or you may simply want to use NSRunLoopCommonModes.</p>

<p>Accepted sockets will automatically inherit the same run loop modes as the listening socket.</p>

<p>Note: NSRunLoopCommonModes is defined in 10.5. For previous versions one can use kCFRunLoopCommonModes.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/unreadData" title="unreadData"></a>
	<h3 class="method-title"><code><a href="#//api/name/unreadData">&ndash;&nbsp;unreadData</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read
any data that&rsquo;s left on the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSData *)unreadData</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read
any data that&rsquo;s left on the socket.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/createAcceptSocketForAddress:error:" title="createAcceptSocketForAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createAcceptSocketForAddress:error:">&ndash;&nbsp;createAcceptSocketForAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the accept sockets.
Returns true if either IPv4 or IPv6 is created.
If either is missing, an error is returned (even though the method may return true).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (CFSocketRef)createAcceptSocketForAddress:(NSData *)<em>addr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Creates the accept sockets.
Returns true if either IPv4 or IPv6 is created.
If either is missing, an error is returned (even though the method may return true).</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/attachSocketsToRunLoop:error:" title="attachSocketsToRunLoop:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/attachSocketsToRunLoop:error:">&ndash;&nbsp;attachSocketsToRunLoop:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Adds the CFSocket&rsquo;s to the run-loop so that callbacks will work properly.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)attachSocketsToRunLoop:(NSRunLoop *)<em>runLoop</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Adds the CFSocket&rsquo;s to the run-loop so that callbacks will work properly.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/configureSocketAndReturnError:" title="configureSocketAndReturnError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/configureSocketAndReturnError:">&ndash;&nbsp;configureSocketAndReturnError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows the <a href="#//api/name/delegate">delegate</a> method to configure the CFSocket or CFNativeSocket as desired before we connect.
Note that the CFReadStream and CFWriteStream will not be available until after the connection is opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)configureSocketAndReturnError:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Allows the <a href="#//api/name/delegate">delegate</a> method to configure the CFSocket or CFNativeSocket as desired before we connect.
Note that the CFReadStream and CFWriteStream will not be available until after the connection is opened.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doAcceptWithSocket:" title="doAcceptWithSocket:"></a>
	<h3 class="method-title"><code><a href="#//api/name/doAcceptWithSocket:">&ndash;&nbsp;doAcceptWithSocket:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Attempt to make the new socket.
If an error occurs, ignore this event.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doAcceptWithSocket:(CFSocketNativeHandle)<em>newNative</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Attempt to make the new socket.
If an error occurs, ignore this event.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doSocketOpen:withCFSocketError:" title="doSocketOpen:withCFSocketError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/doSocketOpen:withCFSocketError:">&ndash;&nbsp;doSocketOpen:withCFSocketError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Description forthcoming&hellip;</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doSocketOpen:(CFSocketRef)<em>sock</em> withCFSocketError:(CFSocketError)<em>socketError</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Description forthcoming&hellip;</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/createStreamsFromNative:error:" title="createStreamsFromNative:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createStreamsFromNative:error:">&ndash;&nbsp;createStreamsFromNative:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the CFReadStream and CFWriteStream from the given native socket.
The CFSocket may be extracted from either stream after the streams have been opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)createStreamsFromNative:(CFSocketNativeHandle)<em>native</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Creates the CFReadStream and CFWriteStream from the given native socket.
The CFSocket may be extracted from either stream after the streams have been opened.</p>

<p>Note: The given native socket must already be connected!</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/createStreamsToHost:onPort:error:" title="createStreamsToHost:onPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createStreamsToHost:onPort:error:">&ndash;&nbsp;createStreamsToHost:onPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the CFReadStream and CFWriteStream from the given hostname and port number.
The CFSocket may be extracted from either stream after the streams have been opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)createStreamsToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Creates the CFReadStream and CFWriteStream from the given hostname and port number.
The CFSocket may be extracted from either stream after the streams have been opened.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/configureStreamsAndReturnError:" title="configureStreamsAndReturnError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/configureStreamsAndReturnError:">&ndash;&nbsp;configureStreamsAndReturnError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows the <a href="#//api/name/delegate">delegate</a> method to configure the CFReadStream and/or CFWriteStream as desired before we connect.
Note that the CFSocket and CFNativeSocket will not be available until after the connection is opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)configureStreamsAndReturnError:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Allows the <a href="#//api/name/delegate">delegate</a> method to configure the CFReadStream and/or CFWriteStream as desired before we connect.
Note that the CFSocket and CFNativeSocket will not be available until after the connection is opened.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doStreamOpen" title="doStreamOpen"></a>
	<h3 class="method-title"><code><a href="#//api/name/doStreamOpen">&ndash;&nbsp;doStreamOpen</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Called when read or write streams open.
When the socket is connected and both streams are open, consider the AsyncSocket instance to be ready.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doStreamOpen</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Called when read or write streams open.
When the socket is connected and both streams are open, consider the AsyncSocket instance to be ready.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/close" title="close"></a>
	<h3 class="method-title"><code><a href="#//api/name/close">&ndash;&nbsp;close</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects. This is called for both error and clean disconnections.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)close</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects. This is called for both error and clean disconnections.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeScheduleDisconnect" title="maybeScheduleDisconnect"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeScheduleDisconnect">&ndash;&nbsp;maybeScheduleDisconnect</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Schedules a call to <a href="#//api/name/disconnect">disconnect</a> if possible.
That is, if all writes have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after writing,
or if all reads have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after reading.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeScheduleDisconnect</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Schedules a call to <a href="#//api/name/disconnect">disconnect</a> if possible.
That is, if all writes have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after writing,
or if all reads have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after reading.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getErrnoError" title="getErrnoError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getErrnoError">&ndash;&nbsp;getErrnoError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard error object for the current errno value.
Errno is used for low-level BSD socket errors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getErrnoError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard error object for the current errno value.
Errno is used for low-level BSD socket errors.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getSocketError" title="getSocketError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getSocketError">&ndash;&nbsp;getSocketError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard error message for a CFSocket error.
Unfortunately, CFSocket offers no feedback on its errors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getSocketError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard error message for a CFSocket error.
Unfortunately, CFSocket offers no feedback on its errors.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getAbortError" title="getAbortError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getAbortError">&ndash;&nbsp;getAbortError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket abort error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getAbortError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket abort error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getConnectTimeoutError" title="getConnectTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getConnectTimeoutError">&ndash;&nbsp;getConnectTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket connect timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getConnectTimeoutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket connect timeout error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getReadMaxedOutError" title="getReadMaxedOutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getReadMaxedOutError">&ndash;&nbsp;getReadMaxedOutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket maxed out error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getReadMaxedOutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket maxed out error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getReadTimeoutError" title="getReadTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getReadTimeoutError">&ndash;&nbsp;getReadTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket read timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getReadTimeoutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket read timeout error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getWriteTimeoutError" title="getWriteTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getWriteTimeoutError">&ndash;&nbsp;getWriteTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket write timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getWriteTimeoutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket write timeout error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/scheduleDequeueRead" title="scheduleDequeueRead"></a>
	<h3 class="method-title"><code><a href="#//api/name/scheduleDequeueRead">&ndash;&nbsp;scheduleDequeueRead</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Puts a <a href="#//api/name/maybeDequeueRead">maybeDequeueRead</a> on the run loop.
An assumption here is that selectors will be performed consecutively within their priority.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)scheduleDequeueRead</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Puts a <a href="#//api/name/maybeDequeueRead">maybeDequeueRead</a> on the run loop.
An assumption here is that selectors will be performed consecutively within their priority.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeDequeueRead" title="maybeDequeueRead"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeDequeueRead">&ndash;&nbsp;maybeDequeueRead</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method starts a new read, if needed.
It is called when a user requests a read,
or when a stream opens that may have requested reads sitting in the queue, etc.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeDequeueRead</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method starts a new read, if needed.
It is called when a user requests a read,
or when a stream opens that may have requested reads sitting in the queue, etc.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/hasBytesAvailable" title="hasBytesAvailable"></a>
	<h3 class="method-title"><code><a href="#//api/name/hasBytesAvailable">&ndash;&nbsp;hasBytesAvailable</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamHasBytesAvailable().
This method supports pre-buffering properly.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)hasBytesAvailable</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamHasBytesAvailable().
This method supports pre-buffering properly.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readIntoBuffer:maxLength:" title="readIntoBuffer:maxLength:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readIntoBuffer:maxLength:">&ndash;&nbsp;readIntoBuffer:maxLength:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamRead().
This method support pre-buffering properly.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (CFIndex)readIntoBuffer:(UInt8 *)<em>buffer</em> maxLength:(CFIndex)<em>length</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamRead().
This method support pre-buffering properly.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doBytesAvailable" title="doBytesAvailable"></a>
	<h3 class="method-title"><code><a href="#//api/name/doBytesAvailable">&ndash;&nbsp;doBytesAvailable</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is called when a new read is taken from the read queue or when new data becomes available on the stream.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doBytesAvailable</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is called when a new read is taken from the read queue or when new data becomes available on the stream.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2015 youdao. All rights reserved. Updated: 2015-12-28</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>